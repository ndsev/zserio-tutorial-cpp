#ifndef ZSERIO_BIT_BUFFER_H_INC
#define ZSERIO_BIT_BUFFER_H_INC

#include <cstddef>
#include <cstring>
#include <vector>
#include <type_traits>

#include "zserio/Types.h"
#include "zserio/HashCodeUtil.h"
#include "zserio/CppRuntimeException.h"

namespace zserio
{

/**
 * Bits helper structure used as a tag in BitStreamReader and BitStreamWriter constructor to pass number of bits
 * instead of number of bytes.
 */
struct BitsTag
{};

/**
 * Class which holds any bit sequence.
 *
 * Because bit buffer size does not have to be byte aligned (divisible by 8), it's possible that not all bits
 * of the last byte are used. In this case, only most significant bits of the corresponded size are used.
 */
template <typename ALLOC = std::allocator<uint8_t>>
class BasicBitBuffer
{
public:
    static_assert(std::is_same<uint8_t, typename ALLOC::value_type>::value,
            "Allocator with uint8_t value_type is required!");

    using allocator_type = ALLOC;

    /**
     * Get copy of the allocator used for dynamic memory allocations.
     *
     * \return Allocator used for dynamic memory allocations.
     */
    allocator_type get_allocator() const
    {
        return m_buffer.get_allocator();
    }

    /**
     * Empty constructor.
     */
    BasicBitBuffer(const ALLOC& allocator = ALLOC());

    /**
     * Constructor from bit size.
     *
     * \param bitSize Size in bits of created bit buffer.
     */
    explicit BasicBitBuffer(size_t bitSize, const ALLOC& allocator = ALLOC());

    /**
     * Constructor from STL vector.
     *
     * \param buffer STL vector of bytes from which the bit buffer should be created.
     */
    explicit BasicBitBuffer(const std::vector<uint8_t, ALLOC>& buffer);

    /**
     * Constructor from STL vector and bit size.
     *
     * \param buffer STL vector of bytes from which the bit buffer should be created.
     * \param bitSize Number of bits stored in buffer to use.
     *
     * \throw CppRuntimeException If given bit size is out of range for given vector.
     */
    explicit BasicBitBuffer(const std::vector<uint8_t, ALLOC>& buffer, size_t bitSize);

    /**
     * Constructor from moved STL vector.
     *
     * \param buffer STL vector of bytes from which the bit buffer should be created.
     */
    explicit BasicBitBuffer(std::vector<uint8_t, ALLOC>&& buffer);

    /**
     * Constructor from moved STL vector and bit size.
     *
     * \param buffer STL vector of bytes from which the bit buffer should be created.
     * \param bitSize Number of bits stored in buffer to use.
     *
     * \throw CppRuntimeException If given bit size is out of range for given vector.
     */
    explicit BasicBitBuffer(std::vector<uint8_t, ALLOC>&& buffer, size_t bitSize);

    /**
     * Constructor from raw pointer.
     *
     * \param buffer Raw pointer to all bytes from which the bit buffer should be created.
     * \param bitSize Number of bits stored in buffer to use.
     */
    explicit BasicBitBuffer(const uint8_t* buffer, size_t bitSize, const ALLOC& allocator = ALLOC());

    /**
     * Method generated by default.
     * \{
     */
    ~BasicBitBuffer() = default;

    BasicBitBuffer(const BasicBitBuffer<ALLOC>&) = default;
    BasicBitBuffer(const BasicBitBuffer<ALLOC>& other, const ALLOC& allocator);
    BasicBitBuffer& operator=(const BasicBitBuffer<ALLOC>&) = default;

    BasicBitBuffer(BasicBitBuffer<ALLOC>&&) = default;
    BasicBitBuffer(const BasicBitBuffer<ALLOC>&& other, const ALLOC& allocator);
    BasicBitBuffer& operator=(BasicBitBuffer<ALLOC>&&) = default;
    /**
     * \}
     */

    /**
     * Equal operator.
     *
     * \param other The another instance of bit buffer to which compare this bit buffer.
     */
    bool operator==(const BasicBitBuffer<ALLOC>& other) const;

    /**
     * Calculates hash code of the bit buffer.
     *
     * \return Calculated hash code.
     */
    uint32_t hashCode() const;

    /**
     * Gets the underlying buffer.
     *
     * \return Pointer to the constant underlying buffer.
     */
    const uint8_t* getBuffer() const;

    /**
     * Gets the underlying buffer.
     *
     * \return Pointer to the underlying buffer.
     */
    uint8_t* getBuffer();

    /**
     * Gets the number of bits stored in the bit buffer.
     *
     * \return Bit buffer size in bits.
     */
    size_t getBitSize() const;

    /**
     * Gets the number of bytes stored in the bit buffer.
     *
     * Not all bits of the last byte must be used. Unused bits of the last byte are set to zero.
     *
     * \return Bit buffer size in bytes.
     */
    size_t getByteSize() const;

private:
    uint8_t getMaskedLastByte() const;

    std::vector<uint8_t, ALLOC> m_buffer;
    size_t m_bitSize;
};

template <typename ALLOC>
BasicBitBuffer<ALLOC>::BasicBitBuffer(const ALLOC& allocator) :
        m_buffer(allocator), m_bitSize(0)
{
}

template <typename ALLOC>
BasicBitBuffer<ALLOC>::BasicBitBuffer(size_t bitSize, const ALLOC& allocator) :
        m_buffer((bitSize + 7) / 8, 0, allocator), m_bitSize(bitSize)
{
}

template <typename ALLOC>
BasicBitBuffer<ALLOC>::BasicBitBuffer(const std::vector<uint8_t, ALLOC>& buffer) :
        m_buffer(buffer), m_bitSize(8 * buffer.size())
{
}

template <typename ALLOC>
BasicBitBuffer<ALLOC>::BasicBitBuffer(const std::vector<uint8_t, ALLOC>& buffer, size_t bitSize) :
        m_buffer(buffer.get_allocator()), m_bitSize(bitSize)
{
    const size_t byteSize = (bitSize + 7) / 8;
    if (buffer.size() < byteSize)
    {
        throw CppRuntimeException("BitBuffer: Bit size ") + bitSize +
                " out of range for given vector byte size " + buffer.size() + "!";
    }

    m_buffer.assign(buffer.data(), buffer.data() + byteSize);
}

template <typename ALLOC>
BasicBitBuffer<ALLOC>::BasicBitBuffer(std::vector<uint8_t, ALLOC>&& buffer) :
        m_buffer(std::move(buffer)), m_bitSize(8 * m_buffer.size())
{
}

template <typename ALLOC>
BasicBitBuffer<ALLOC>::BasicBitBuffer(std::vector<uint8_t, ALLOC>&& buffer, size_t bitSize) :
        m_buffer(std::move(buffer)), m_bitSize(bitSize)
{
    const size_t byteSize = (bitSize + 7) / 8;
    if (m_buffer.size() < byteSize)
    {
        throw CppRuntimeException("BitBuffer: Bit size ") + bitSize +
                " out of range for given vector byte size " + buffer.size() + "!";
    }
}

template <typename ALLOC>
BasicBitBuffer<ALLOC>::BasicBitBuffer(const uint8_t* buffer, size_t bitSize, const ALLOC& allocator) :
        m_buffer(buffer, buffer + (bitSize + 7) / 8, allocator), m_bitSize(bitSize)
{
}

template<typename ALLOC>
inline BasicBitBuffer<ALLOC>::BasicBitBuffer(const BasicBitBuffer<ALLOC>& other, const ALLOC& allocator) :
        m_buffer(other.m_buffer, allocator), m_bitSize(other.m_bitSize)
{
}

template<typename ALLOC>
inline BasicBitBuffer<ALLOC>::BasicBitBuffer(const BasicBitBuffer<ALLOC>&& other, const ALLOC& allocator) :
        m_buffer(std::move(other.m_buffer), allocator), m_bitSize(other.m_bitSize)
{
}

template <typename ALLOC>
bool BasicBitBuffer<ALLOC>::operator==(const BasicBitBuffer<ALLOC>& other) const
{
    if (this != &other)
    {
        if (m_bitSize != other.m_bitSize)
            return false;

        const size_t byteSize = getByteSize();
        if (byteSize > 0)
        {
            if (byteSize > 1)
            {
                if (memcmp(getBuffer(), other.getBuffer(), byteSize - 1) != 0)
                    return false;
            }

            if (getMaskedLastByte() != other.getMaskedLastByte())
                return false;
        }
    }

    return true;
}

template <typename ALLOC>
uint32_t BasicBitBuffer<ALLOC>::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    const size_t byteSize = getByteSize();
    if (byteSize > 0)
    {
        if (byteSize > 1)
        {
            const uint8_t* lastElement = getBuffer() + byteSize - 1;
            for (const uint8_t* p = getBuffer(); p < lastElement; p++)
                result = calcHashCode(result, *p);
        }
        result = ::zserio::calcHashCode(result, getMaskedLastByte());
    }

    return result;
}

template <typename ALLOC>
const uint8_t* BasicBitBuffer<ALLOC>::getBuffer() const
{
    return m_buffer.data();
}

template <typename ALLOC>
uint8_t* BasicBitBuffer<ALLOC>::getBuffer()
{
    return m_buffer.data();
}

template <typename ALLOC>
size_t BasicBitBuffer<ALLOC>::getBitSize() const
{
    return m_bitSize;
}

template <typename ALLOC>
size_t BasicBitBuffer<ALLOC>::getByteSize() const
{
    return (m_bitSize + 7) / 8;
}

template <typename ALLOC>
uint8_t BasicBitBuffer<ALLOC>::getMaskedLastByte() const
{
    const size_t roundedByteSize = m_bitSize / 8;
    const uint8_t lastByteBits = static_cast<uint8_t>(m_bitSize - 8 * roundedByteSize);

    return (lastByteBits == 0) ? m_buffer[roundedByteSize - 1] :
            (m_buffer[roundedByteSize] & (0xFF << (8 - lastByteBits)));
}

using BitBuffer = BasicBitBuffer<>;

} // namespace zserio

#endif // ifndef ZSERIO_BIT_BUFFER_H_INC
